#code1
dr = [1, 0]
dc = [0, 1]

def solve(r,c):
    global minV, sumV
    if minV < sumV:
        return
    if r == N-1 and c == N-1:
        if minV > sumV:
            minV = sumV
        return

    for d in range(2):
        nr = r + dr[d]
        nc = c + dc[d]

        if 0 <= nr < N and 0 <= nc < N and (nr, nc):
            sumV += data[nr][nc]
            solve(nr, nc)
            sumV -= data[nr][nc]

T = int(input())
for tc in range(1, T+1):
    N = int(input())
    data = [list(map(int, input().split())) for _ in range(N)]
    minV = 100000000
    sumV = data[0][0]
    solve(0, 0)
    print(f'#{tc} {minV}')





#code2
# --<<2. 경로의 최소합 찾기 위한 함수>>-----------------------------------------------------------------------------------
def sol(i, j, sm):                          # 문제 해결 위한 함수,
    # i : row의 시작 인덱스
    # j: column 의 시작 인덱스
    # sm : 현재까지 거쳐온 수의 합

    global min_sum                          # 최솟값 저장 위해 min_sum 가져오기

    # --<<2-3. 종료 조건, 최솟값 검증>>----------------------------------------------------------------------------------
    if (i, j) == (N-1, N-1):                # 종료 조건, 맨 오른쪽 아래까지 도착했을 때 종료
        sm += arr[i][j]                     # 마지막 칸의 수 더해주면서 모든 경로에 대한 합 완성
        if sm < min_sum:                    # 최솟값 검증
            min_sum = sm
            return

    # --<<2-2. 과정 중 검증, 쓸데 없이 더 가지 말기>>-----------------------------------------------------------------------
    if sm > min_sum:                        # 현재까지의 경로의 합이 이미 최솟값보다 크다면
        return                              # 더 갈 필요 없이 리턴

    # --<<2-1. 경로에 대한 합 구하기 위한 과정>>----------------------------------------------------------------------------
    new_sm = sm + arr[i][j]                 # 현재 수 new_sm에 더해 저장

    if i < N-1:                             # 범위를 벗어나지 않는다면
        sol(i+1, j, new_sm)                 # 아래쪽으로 가 다시 함수 수행하자

    if j < N-1:                             # 범위를 벗어나지 않는다면
        sol(i, j+1, new_sm)                 # 오른쪽으로 가 다시 함수 수행하자


# --<<1. 데이터 받기>>----------------------------------------------------------------------------
T = int(input())                            # 테스트 케이스 수 T 받기
for tc in range(1, T+1):                   # 테스트 케이스의 수 T 만큼 반복한다.
    N = int(input())                        # 가로, 세로 칸 수인 N 받기
    arr = [list(map(int, input().split())) for _ in range(N)]   # 데이터 입력받기
    min_sum = (N*2-1)*10+1                        # 주어지는 자연수의 최댓값 = 10, N*N 배열에서 맨 오른쪽 아래까지 가려면 (N*2-1)만큼의 칸을 지남


# --<<3. 함수 실행 및 정답 출력>>----------------------------------------------------------------------------
    sol(0, 0, 0)                            # 인덱스 0,0 부터 합은 0인 상태로 함수 실행

    print(f'#{tc} {min_sum}')               # 정답 출력